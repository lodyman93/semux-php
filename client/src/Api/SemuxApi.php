<?php
/**
 * SemuxApi
 * PHP version 5
 *
 * @category Class
 * @package  Semux\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Semux API
 *
 * Semux is an experimental high-performance blockchain platform that powers decentralized application.
 *
 * OpenAPI spec version: 2.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Semux\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Semux\Client\ApiException;
use Semux\Client\Configuration;
use Semux\Client\HeaderSelector;
use Semux\Client\ObjectSerializer;

/**
 * SemuxApi Class Doc Comment
 *
 * @category Class
 * @package  Semux\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SemuxApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addNode
     *
     * Add node
     *
     * @param  string $node Address of the node in host:port format (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\AddNodeResponse
     */
    public function addNode($node)
    {
        list($response) = $this->addNodeWithHttpInfo($node);
        return $response;
    }

    /**
     * Operation addNodeWithHttpInfo
     *
     * Add node
     *
     * @param  string $node Address of the node in host:port format (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\AddNodeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addNodeWithHttpInfo($node)
    {
        $returnType = '\Semux\Client\Model\AddNodeResponse';
        $request = $this->addNodeRequest($node);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\AddNodeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addNodeAsync
     *
     * Add node
     *
     * @param  string $node Address of the node in host:port format (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addNodeAsync($node)
    {
        return $this->addNodeAsyncWithHttpInfo($node)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addNodeAsyncWithHttpInfo
     *
     * Add node
     *
     * @param  string $node Address of the node in host:port format (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addNodeAsyncWithHttpInfo($node)
    {
        $returnType = '\Semux\Client\Model\AddNodeResponse';
        $request = $this->addNodeRequest($node);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addNode'
     *
     * @param  string $node Address of the node in host:port format (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addNodeRequest($node)
    {
        // verify the required parameter 'node' is set
        if ($node === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling addNode'
            );
        }

        $resourcePath = '/node';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($node !== null) {
            $queryParams['node'] = ObjectSerializer::toQueryValue($node);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addToBlacklist
     *
     * Add to blacklist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\ApiHandlerResponse
     */
    public function addToBlacklist($ip)
    {
        list($response) = $this->addToBlacklistWithHttpInfo($ip);
        return $response;
    }

    /**
     * Operation addToBlacklistWithHttpInfo
     *
     * Add to blacklist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\ApiHandlerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addToBlacklistWithHttpInfo($ip)
    {
        $returnType = '\Semux\Client\Model\ApiHandlerResponse';
        $request = $this->addToBlacklistRequest($ip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\ApiHandlerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addToBlacklistAsync
     *
     * Add to blacklist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToBlacklistAsync($ip)
    {
        return $this->addToBlacklistAsyncWithHttpInfo($ip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addToBlacklistAsyncWithHttpInfo
     *
     * Add to blacklist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToBlacklistAsyncWithHttpInfo($ip)
    {
        $returnType = '\Semux\Client\Model\ApiHandlerResponse';
        $request = $this->addToBlacklistRequest($ip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addToBlacklist'
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addToBlacklistRequest($ip)
    {
        // verify the required parameter 'ip' is set
        if ($ip === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling addToBlacklist'
            );
        }
        if (!preg_match("/^(\\d{1,3}\\.){3}\\d{1,3}$/", $ip)) {
            throw new \InvalidArgumentException("invalid value for \"ip\" when calling SemuxApi.addToBlacklist, must conform to the pattern /^(\\d{1,3}\\.){3}\\d{1,3}$/.");
        }


        $resourcePath = '/blacklist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addToWhitelist
     *
     * Add to whitelist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\ApiHandlerResponse
     */
    public function addToWhitelist($ip)
    {
        list($response) = $this->addToWhitelistWithHttpInfo($ip);
        return $response;
    }

    /**
     * Operation addToWhitelistWithHttpInfo
     *
     * Add to whitelist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\ApiHandlerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addToWhitelistWithHttpInfo($ip)
    {
        $returnType = '\Semux\Client\Model\ApiHandlerResponse';
        $request = $this->addToWhitelistRequest($ip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\ApiHandlerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addToWhitelistAsync
     *
     * Add to whitelist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToWhitelistAsync($ip)
    {
        return $this->addToWhitelistAsyncWithHttpInfo($ip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addToWhitelistAsyncWithHttpInfo
     *
     * Add to whitelist
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addToWhitelistAsyncWithHttpInfo($ip)
    {
        $returnType = '\Semux\Client\Model\ApiHandlerResponse';
        $request = $this->addToWhitelistRequest($ip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addToWhitelist'
     *
     * @param  string $ip IP address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addToWhitelistRequest($ip)
    {
        // verify the required parameter 'ip' is set
        if ($ip === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling addToWhitelist'
            );
        }
        if (!preg_match("/^(\\d{1,3}\\.){3}\\d{1,3}$/", $ip)) {
            throw new \InvalidArgumentException("invalid value for \"ip\" when calling SemuxApi.addToWhitelist, must conform to the pattern /^(\\d{1,3}\\.){3}\\d{1,3}$/.");
        }


        $resourcePath = '/whitelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation broadcastRawTransaction
     *
     * Broadcast a raw transaction
     *
     * @param  string $raw Raw transaction encoded in hexadecimal string. (required)
     * @param  bool $validateNonce Whether to validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DoTransactionResponse
     */
    public function broadcastRawTransaction($raw, $validateNonce = 'false')
    {
        list($response) = $this->broadcastRawTransactionWithHttpInfo($raw, $validateNonce);
        return $response;
    }

    /**
     * Operation broadcastRawTransactionWithHttpInfo
     *
     * Broadcast a raw transaction
     *
     * @param  string $raw Raw transaction encoded in hexadecimal string. (required)
     * @param  bool $validateNonce Whether to validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DoTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function broadcastRawTransactionWithHttpInfo($raw, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->broadcastRawTransactionRequest($raw, $validateNonce);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DoTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation broadcastRawTransactionAsync
     *
     * Broadcast a raw transaction
     *
     * @param  string $raw Raw transaction encoded in hexadecimal string. (required)
     * @param  bool $validateNonce Whether to validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastRawTransactionAsync($raw, $validateNonce = 'false')
    {
        return $this->broadcastRawTransactionAsyncWithHttpInfo($raw, $validateNonce)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation broadcastRawTransactionAsyncWithHttpInfo
     *
     * Broadcast a raw transaction
     *
     * @param  string $raw Raw transaction encoded in hexadecimal string. (required)
     * @param  bool $validateNonce Whether to validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastRawTransactionAsyncWithHttpInfo($raw, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->broadcastRawTransactionRequest($raw, $validateNonce);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'broadcastRawTransaction'
     *
     * @param  string $raw Raw transaction encoded in hexadecimal string. (required)
     * @param  bool $validateNonce Whether to validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function broadcastRawTransactionRequest($raw, $validateNonce = 'false')
    {
        // verify the required parameter 'raw' is set
        if ($raw === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $raw when calling broadcastRawTransaction'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]+$/", $raw)) {
            throw new \InvalidArgumentException("invalid value for \"raw\" when calling SemuxApi.broadcastRawTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]+$/.");
        }


        $resourcePath = '/transaction/raw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($raw !== null) {
            $queryParams['raw'] = ObjectSerializer::toQueryValue($raw);
        }
        // query params
        if ($validateNonce !== null) {
            $queryParams['validateNonce'] = ObjectSerializer::toQueryValue($validateNonce);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation composeRawTransaction
     *
     * Compose an unsigned raw transaction
     *
     * @param  string $network Network name (required)
     * @param  string $type Transaction type (required)
     * @param  string $fee Transaction fee in nano (required)
     * @param  string $nonce Transaction nonce (required)
     * @param  string $to Recipient&#39;s address (optional)
     * @param  string $value Transaction value in nano SEM (optional)
     * @param  string $timestamp Transaction timestamp in milliseconds. Default to current time. (optional)
     * @param  string $data Hexadecimal encoded transaction data. (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\ComposeRawTransactionResponse
     */
    public function composeRawTransaction($network, $type, $fee, $nonce, $to = null, $value = null, $timestamp = null, $data = null)
    {
        list($response) = $this->composeRawTransactionWithHttpInfo($network, $type, $fee, $nonce, $to, $value, $timestamp, $data);
        return $response;
    }

    /**
     * Operation composeRawTransactionWithHttpInfo
     *
     * Compose an unsigned raw transaction
     *
     * @param  string $network Network name (required)
     * @param  string $type Transaction type (required)
     * @param  string $fee Transaction fee in nano (required)
     * @param  string $nonce Transaction nonce (required)
     * @param  string $to Recipient&#39;s address (optional)
     * @param  string $value Transaction value in nano SEM (optional)
     * @param  string $timestamp Transaction timestamp in milliseconds. Default to current time. (optional)
     * @param  string $data Hexadecimal encoded transaction data. (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\ComposeRawTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function composeRawTransactionWithHttpInfo($network, $type, $fee, $nonce, $to = null, $value = null, $timestamp = null, $data = null)
    {
        $returnType = '\Semux\Client\Model\ComposeRawTransactionResponse';
        $request = $this->composeRawTransactionRequest($network, $type, $fee, $nonce, $to, $value, $timestamp, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\ComposeRawTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation composeRawTransactionAsync
     *
     * Compose an unsigned raw transaction
     *
     * @param  string $network Network name (required)
     * @param  string $type Transaction type (required)
     * @param  string $fee Transaction fee in nano (required)
     * @param  string $nonce Transaction nonce (required)
     * @param  string $to Recipient&#39;s address (optional)
     * @param  string $value Transaction value in nano SEM (optional)
     * @param  string $timestamp Transaction timestamp in milliseconds. Default to current time. (optional)
     * @param  string $data Hexadecimal encoded transaction data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function composeRawTransactionAsync($network, $type, $fee, $nonce, $to = null, $value = null, $timestamp = null, $data = null)
    {
        return $this->composeRawTransactionAsyncWithHttpInfo($network, $type, $fee, $nonce, $to, $value, $timestamp, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation composeRawTransactionAsyncWithHttpInfo
     *
     * Compose an unsigned raw transaction
     *
     * @param  string $network Network name (required)
     * @param  string $type Transaction type (required)
     * @param  string $fee Transaction fee in nano (required)
     * @param  string $nonce Transaction nonce (required)
     * @param  string $to Recipient&#39;s address (optional)
     * @param  string $value Transaction value in nano SEM (optional)
     * @param  string $timestamp Transaction timestamp in milliseconds. Default to current time. (optional)
     * @param  string $data Hexadecimal encoded transaction data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function composeRawTransactionAsyncWithHttpInfo($network, $type, $fee, $nonce, $to = null, $value = null, $timestamp = null, $data = null)
    {
        $returnType = '\Semux\Client\Model\ComposeRawTransactionResponse';
        $request = $this->composeRawTransactionRequest($network, $type, $fee, $nonce, $to, $value, $timestamp, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'composeRawTransaction'
     *
     * @param  string $network Network name (required)
     * @param  string $type Transaction type (required)
     * @param  string $fee Transaction fee in nano (required)
     * @param  string $nonce Transaction nonce (required)
     * @param  string $to Recipient&#39;s address (optional)
     * @param  string $value Transaction value in nano SEM (optional)
     * @param  string $timestamp Transaction timestamp in milliseconds. Default to current time. (optional)
     * @param  string $data Hexadecimal encoded transaction data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function composeRawTransactionRequest($network, $type, $fee, $nonce, $to = null, $value = null, $timestamp = null, $data = null)
    {
        // verify the required parameter 'network' is set
        if ($network === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling composeRawTransaction'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling composeRawTransaction'
            );
        }
        // verify the required parameter 'fee' is set
        if ($fee === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fee when calling composeRawTransaction'
            );
        }
        if (!preg_match("/^\\d+$/", $fee)) {
            throw new \InvalidArgumentException("invalid value for \"fee\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^\\d+$/.");
        }

        // verify the required parameter 'nonce' is set
        if ($nonce === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling composeRawTransaction'
            );
        }
        if (!preg_match("/^\\d+$/", $nonce)) {
            throw new \InvalidArgumentException("invalid value for \"nonce\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^\\d+$/.");
        }

        if ($to !== null && !preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        if ($value !== null && !preg_match("/^\\d+$/", $value)) {
            throw new \InvalidArgumentException("invalid value for \"value\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^\\d+$/.");
        }

        if ($timestamp !== null && !preg_match("/^\\d+$/", $timestamp)) {
            throw new \InvalidArgumentException("invalid value for \"timestamp\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^\\d+$/.");
        }

        if ($data !== null && !preg_match("/^(0x)?[0-9a-fA-F]+$/", $data)) {
            throw new \InvalidArgumentException("invalid value for \"data\" when calling SemuxApi.composeRawTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]+$/.");
        }


        $resourcePath = '/compose-raw-transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($network !== null) {
            $queryParams['network'] = ObjectSerializer::toQueryValue($network);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($fee !== null) {
            $queryParams['fee'] = ObjectSerializer::toQueryValue($fee);
        }
        // query params
        if ($nonce !== null) {
            $queryParams['nonce'] = ObjectSerializer::toQueryValue($nonce);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($timestamp !== null) {
            $queryParams['timestamp'] = ObjectSerializer::toQueryValue($timestamp);
        }
        // query params
        if ($data !== null) {
            $queryParams['data'] = ObjectSerializer::toQueryValue($data);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccount
     *
     * Create or import an account
     *
     * @param  string $name Assigned alias to the created account. (optional)
     * @param  string $privateKey The private key to be imported, create a new key if omitted (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\CreateAccountResponse
     */
    public function createAccount($name = null, $privateKey = null)
    {
        list($response) = $this->createAccountWithHttpInfo($name, $privateKey);
        return $response;
    }

    /**
     * Operation createAccountWithHttpInfo
     *
     * Create or import an account
     *
     * @param  string $name Assigned alias to the created account. (optional)
     * @param  string $privateKey The private key to be imported, create a new key if omitted (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\CreateAccountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountWithHttpInfo($name = null, $privateKey = null)
    {
        $returnType = '\Semux\Client\Model\CreateAccountResponse';
        $request = $this->createAccountRequest($name, $privateKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\CreateAccountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountAsync
     *
     * Create or import an account
     *
     * @param  string $name Assigned alias to the created account. (optional)
     * @param  string $privateKey The private key to be imported, create a new key if omitted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAsync($name = null, $privateKey = null)
    {
        return $this->createAccountAsyncWithHttpInfo($name, $privateKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountAsyncWithHttpInfo
     *
     * Create or import an account
     *
     * @param  string $name Assigned alias to the created account. (optional)
     * @param  string $privateKey The private key to be imported, create a new key if omitted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAsyncWithHttpInfo($name = null, $privateKey = null)
    {
        $returnType = '\Semux\Client\Model\CreateAccountResponse';
        $request = $this->createAccountRequest($name, $privateKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccount'
     *
     * @param  string $name Assigned alias to the created account. (optional)
     * @param  string $privateKey The private key to be imported, create a new key if omitted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountRequest($name = null, $privateKey = null)
    {
        if ($privateKey !== null && !preg_match("/^(0x)?[0-9a-fA-F]{96}$/", $privateKey)) {
            throw new \InvalidArgumentException("invalid value for \"privateKey\" when calling SemuxApi.createAccount, must conform to the pattern /^(0x)?[0-9a-fA-F]{96}$/.");
        }


        $resourcePath = '/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($privateKey !== null) {
            $queryParams['privateKey'] = ObjectSerializer::toQueryValue($privateKey);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAccount
     *
     * Delete account
     *
     * @param  string $address Address of the account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DeleteAccountResponse
     */
    public function deleteAccount($address)
    {
        list($response) = $this->deleteAccountWithHttpInfo($address);
        return $response;
    }

    /**
     * Operation deleteAccountWithHttpInfo
     *
     * Delete account
     *
     * @param  string $address Address of the account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DeleteAccountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAccountWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\DeleteAccountResponse';
        $request = $this->deleteAccountRequest($address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DeleteAccountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAccountAsync
     *
     * Delete account
     *
     * @param  string $address Address of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAccountAsync($address)
    {
        return $this->deleteAccountAsyncWithHttpInfo($address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAccountAsyncWithHttpInfo
     *
     * Delete account
     *
     * @param  string $address Address of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAccountAsyncWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\DeleteAccountResponse';
        $request = $this->deleteAccountRequest($address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAccount'
     *
     * @param  string $address Address of the account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAccountRequest($address)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling deleteAccount'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.deleteAccount, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccount
     *
     * Get account
     *
     * @param  string $address Address of account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetAccountResponse
     */
    public function getAccount($address)
    {
        list($response) = $this->getAccountWithHttpInfo($address);
        return $response;
    }

    /**
     * Operation getAccountWithHttpInfo
     *
     * Get account
     *
     * @param  string $address Address of account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetAccountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetAccountResponse';
        $request = $this->getAccountRequest($address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetAccountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAsync
     *
     * Get account
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsync($address)
    {
        return $this->getAccountAsyncWithHttpInfo($address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAsyncWithHttpInfo
     *
     * Get account
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsyncWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetAccountResponse';
        $request = $this->getAccountRequest($address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccount'
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountRequest($address)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getAccount'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.getAccount, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountPendingTransactions
     *
     * Get pending transactions of the account
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetAccountPendingTransactionsResponse
     */
    public function getAccountPendingTransactions($address, $from, $to)
    {
        list($response) = $this->getAccountPendingTransactionsWithHttpInfo($address, $from, $to);
        return $response;
    }

    /**
     * Operation getAccountPendingTransactionsWithHttpInfo
     *
     * Get pending transactions of the account
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetAccountPendingTransactionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountPendingTransactionsWithHttpInfo($address, $from, $to)
    {
        $returnType = '\Semux\Client\Model\GetAccountPendingTransactionsResponse';
        $request = $this->getAccountPendingTransactionsRequest($address, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetAccountPendingTransactionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountPendingTransactionsAsync
     *
     * Get pending transactions of the account
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountPendingTransactionsAsync($address, $from, $to)
    {
        return $this->getAccountPendingTransactionsAsyncWithHttpInfo($address, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountPendingTransactionsAsyncWithHttpInfo
     *
     * Get pending transactions of the account
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountPendingTransactionsAsyncWithHttpInfo($address, $from, $to)
    {
        $returnType = '\Semux\Client\Model\GetAccountPendingTransactionsResponse';
        $request = $this->getAccountPendingTransactionsRequest($address, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountPendingTransactions'
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountPendingTransactionsRequest($address, $from, $to)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getAccountPendingTransactions'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.getAccountPendingTransactions, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling getAccountPendingTransactions'
            );
        }
        if (!preg_match("/^\\d+$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.getAccountPendingTransactions, must conform to the pattern /^\\d+$/.");
        }

        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling getAccountPendingTransactions'
            );
        }
        if (!preg_match("/^\\d+$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.getAccountPendingTransactions, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/account/pending-transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountTransactions
     *
     * Get account transactions
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetAccountTransactionsResponse
     */
    public function getAccountTransactions($address, $from, $to)
    {
        list($response) = $this->getAccountTransactionsWithHttpInfo($address, $from, $to);
        return $response;
    }

    /**
     * Operation getAccountTransactionsWithHttpInfo
     *
     * Get account transactions
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetAccountTransactionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountTransactionsWithHttpInfo($address, $from, $to)
    {
        $returnType = '\Semux\Client\Model\GetAccountTransactionsResponse';
        $request = $this->getAccountTransactionsRequest($address, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetAccountTransactionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountTransactionsAsync
     *
     * Get account transactions
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountTransactionsAsync($address, $from, $to)
    {
        return $this->getAccountTransactionsAsyncWithHttpInfo($address, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountTransactionsAsyncWithHttpInfo
     *
     * Get account transactions
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountTransactionsAsyncWithHttpInfo($address, $from, $to)
    {
        $returnType = '\Semux\Client\Model\GetAccountTransactionsResponse';
        $request = $this->getAccountTransactionsRequest($address, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountTransactions'
     *
     * @param  string $address Address of account (required)
     * @param  string $from Starting range of transactions (required)
     * @param  string $to Ending range of transactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountTransactionsRequest($address, $from, $to)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getAccountTransactions'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.getAccountTransactions, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling getAccountTransactions'
            );
        }
        if (!preg_match("/^\\d+$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.getAccountTransactions, must conform to the pattern /^\\d+$/.");
        }

        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling getAccountTransactions'
            );
        }
        if (!preg_match("/^\\d+$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.getAccountTransactions, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/account/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountVotes
     *
     * Get account votes
     *
     * @param  string $address Address of account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetAccountVotesResponse
     */
    public function getAccountVotes($address)
    {
        list($response) = $this->getAccountVotesWithHttpInfo($address);
        return $response;
    }

    /**
     * Operation getAccountVotesWithHttpInfo
     *
     * Get account votes
     *
     * @param  string $address Address of account (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetAccountVotesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountVotesWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetAccountVotesResponse';
        $request = $this->getAccountVotesRequest($address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetAccountVotesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountVotesAsync
     *
     * Get account votes
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountVotesAsync($address)
    {
        return $this->getAccountVotesAsyncWithHttpInfo($address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountVotesAsyncWithHttpInfo
     *
     * Get account votes
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountVotesAsyncWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetAccountVotesResponse';
        $request = $this->getAccountVotesRequest($address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountVotes'
     *
     * @param  string $address Address of account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountVotesRequest($address)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getAccountVotes'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.getAccountVotes, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/account/votes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBlockByHash
     *
     * Get block by hash
     *
     * @param  string $hash Hash of block (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetBlockResponse
     */
    public function getBlockByHash($hash)
    {
        list($response) = $this->getBlockByHashWithHttpInfo($hash);
        return $response;
    }

    /**
     * Operation getBlockByHashWithHttpInfo
     *
     * Get block by hash
     *
     * @param  string $hash Hash of block (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetBlockResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBlockByHashWithHttpInfo($hash)
    {
        $returnType = '\Semux\Client\Model\GetBlockResponse';
        $request = $this->getBlockByHashRequest($hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetBlockResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBlockByHashAsync
     *
     * Get block by hash
     *
     * @param  string $hash Hash of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockByHashAsync($hash)
    {
        return $this->getBlockByHashAsyncWithHttpInfo($hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBlockByHashAsyncWithHttpInfo
     *
     * Get block by hash
     *
     * @param  string $hash Hash of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockByHashAsyncWithHttpInfo($hash)
    {
        $returnType = '\Semux\Client\Model\GetBlockResponse';
        $request = $this->getBlockByHashRequest($hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBlockByHash'
     *
     * @param  string $hash Hash of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBlockByHashRequest($hash)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getBlockByHash'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{64}$/", $hash)) {
            throw new \InvalidArgumentException("invalid value for \"hash\" when calling SemuxApi.getBlockByHash, must conform to the pattern /^(0x)?[0-9a-fA-F]{64}$/.");
        }


        $resourcePath = '/block-by-hash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBlockByNumber
     *
     * Get block by number
     *
     * @param  string $number Number of block (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetBlockResponse
     */
    public function getBlockByNumber($number)
    {
        list($response) = $this->getBlockByNumberWithHttpInfo($number);
        return $response;
    }

    /**
     * Operation getBlockByNumberWithHttpInfo
     *
     * Get block by number
     *
     * @param  string $number Number of block (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetBlockResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBlockByNumberWithHttpInfo($number)
    {
        $returnType = '\Semux\Client\Model\GetBlockResponse';
        $request = $this->getBlockByNumberRequest($number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetBlockResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBlockByNumberAsync
     *
     * Get block by number
     *
     * @param  string $number Number of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockByNumberAsync($number)
    {
        return $this->getBlockByNumberAsyncWithHttpInfo($number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBlockByNumberAsyncWithHttpInfo
     *
     * Get block by number
     *
     * @param  string $number Number of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBlockByNumberAsyncWithHttpInfo($number)
    {
        $returnType = '\Semux\Client\Model\GetBlockResponse';
        $request = $this->getBlockByNumberRequest($number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBlockByNumber'
     *
     * @param  string $number Number of block (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBlockByNumberRequest($number)
    {
        // verify the required parameter 'number' is set
        if ($number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getBlockByNumber'
            );
        }
        if (!preg_match("/^\\d+$/", $number)) {
            throw new \InvalidArgumentException("invalid value for \"number\" when calling SemuxApi.getBlockByNumber, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/block-by-number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDelegate
     *
     * Get a delegate
     *
     * @param  string $address Delegate address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetDelegateResponse
     */
    public function getDelegate($address)
    {
        list($response) = $this->getDelegateWithHttpInfo($address);
        return $response;
    }

    /**
     * Operation getDelegateWithHttpInfo
     *
     * Get a delegate
     *
     * @param  string $address Delegate address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetDelegateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDelegateWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetDelegateResponse';
        $request = $this->getDelegateRequest($address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetDelegateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDelegateAsync
     *
     * Get a delegate
     *
     * @param  string $address Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelegateAsync($address)
    {
        return $this->getDelegateAsyncWithHttpInfo($address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDelegateAsyncWithHttpInfo
     *
     * Get a delegate
     *
     * @param  string $address Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelegateAsyncWithHttpInfo($address)
    {
        $returnType = '\Semux\Client\Model\GetDelegateResponse';
        $request = $this->getDelegateRequest($address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDelegate'
     *
     * @param  string $address Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDelegateRequest($address)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getDelegate'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.getDelegate, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDelegates
     *
     * Get all delegates
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetDelegatesResponse
     */
    public function getDelegates()
    {
        list($response) = $this->getDelegatesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getDelegatesWithHttpInfo
     *
     * Get all delegates
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetDelegatesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDelegatesWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetDelegatesResponse';
        $request = $this->getDelegatesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetDelegatesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDelegatesAsync
     *
     * Get all delegates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelegatesAsync()
    {
        return $this->getDelegatesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDelegatesAsyncWithHttpInfo
     *
     * Get all delegates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelegatesAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetDelegatesResponse';
        $request = $this->getDelegatesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDelegates'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDelegatesRequest()
    {

        $resourcePath = '/delegates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInfo
     *
     * Get info
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetInfoResponse
     */
    public function getInfo()
    {
        list($response) = $this->getInfoWithHttpInfo();
        return $response;
    }

    /**
     * Operation getInfoWithHttpInfo
     *
     * Get info
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInfoWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetInfoResponse';
        $request = $this->getInfoRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInfoAsync
     *
     * Get info
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInfoAsync()
    {
        return $this->getInfoAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInfoAsyncWithHttpInfo
     *
     * Get info
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInfoAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetInfoResponse';
        $request = $this->getInfoRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInfo'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInfoRequest()
    {

        $resourcePath = '/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLatestBlock
     *
     * Get latest block
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetLatestBlockResponse
     */
    public function getLatestBlock()
    {
        list($response) = $this->getLatestBlockWithHttpInfo();
        return $response;
    }

    /**
     * Operation getLatestBlockWithHttpInfo
     *
     * Get latest block
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetLatestBlockResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLatestBlockWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetLatestBlockResponse';
        $request = $this->getLatestBlockRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetLatestBlockResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLatestBlockAsync
     *
     * Get latest block
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestBlockAsync()
    {
        return $this->getLatestBlockAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLatestBlockAsyncWithHttpInfo
     *
     * Get latest block
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestBlockAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetLatestBlockResponse';
        $request = $this->getLatestBlockRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLatestBlock'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLatestBlockRequest()
    {

        $resourcePath = '/latest-block';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLatestBlockNumber
     *
     * Get latest block number
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetLatestBlockNumberResponse
     */
    public function getLatestBlockNumber()
    {
        list($response) = $this->getLatestBlockNumberWithHttpInfo();
        return $response;
    }

    /**
     * Operation getLatestBlockNumberWithHttpInfo
     *
     * Get latest block number
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetLatestBlockNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLatestBlockNumberWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetLatestBlockNumberResponse';
        $request = $this->getLatestBlockNumberRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetLatestBlockNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLatestBlockNumberAsync
     *
     * Get latest block number
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestBlockNumberAsync()
    {
        return $this->getLatestBlockNumberAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLatestBlockNumberAsyncWithHttpInfo
     *
     * Get latest block number
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestBlockNumberAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetLatestBlockNumberResponse';
        $request = $this->getLatestBlockNumberRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLatestBlockNumber'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLatestBlockNumberRequest()
    {

        $resourcePath = '/latest-block-number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPeers
     *
     * Get peers
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetPeersResponse
     */
    public function getPeers()
    {
        list($response) = $this->getPeersWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPeersWithHttpInfo
     *
     * Get peers
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetPeersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPeersWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetPeersResponse';
        $request = $this->getPeersRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetPeersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPeersAsync
     *
     * Get peers
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPeersAsync()
    {
        return $this->getPeersAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPeersAsyncWithHttpInfo
     *
     * Get peers
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPeersAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetPeersResponse';
        $request = $this->getPeersRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPeers'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPeersRequest()
    {

        $resourcePath = '/peers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPendingTransactions
     *
     * Get pending transactions
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetPendingTransactionsResponse
     */
    public function getPendingTransactions()
    {
        list($response) = $this->getPendingTransactionsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPendingTransactionsWithHttpInfo
     *
     * Get pending transactions
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetPendingTransactionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPendingTransactionsWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetPendingTransactionsResponse';
        $request = $this->getPendingTransactionsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetPendingTransactionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPendingTransactionsAsync
     *
     * Get pending transactions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPendingTransactionsAsync()
    {
        return $this->getPendingTransactionsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPendingTransactionsAsyncWithHttpInfo
     *
     * Get pending transactions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPendingTransactionsAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetPendingTransactionsResponse';
        $request = $this->getPendingTransactionsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPendingTransactions'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPendingTransactionsRequest()
    {

        $resourcePath = '/pending-transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSyncingProgress
     *
     * Get syncing progress
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetSyncingProgressResponse
     */
    public function getSyncingProgress()
    {
        list($response) = $this->getSyncingProgressWithHttpInfo();
        return $response;
    }

    /**
     * Operation getSyncingProgressWithHttpInfo
     *
     * Get syncing progress
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetSyncingProgressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSyncingProgressWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetSyncingProgressResponse';
        $request = $this->getSyncingProgressRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetSyncingProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSyncingProgressAsync
     *
     * Get syncing progress
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSyncingProgressAsync()
    {
        return $this->getSyncingProgressAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSyncingProgressAsyncWithHttpInfo
     *
     * Get syncing progress
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSyncingProgressAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetSyncingProgressResponse';
        $request = $this->getSyncingProgressRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSyncingProgress'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSyncingProgressRequest()
    {

        $resourcePath = '/syncing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransaction
     *
     * Get transaction
     *
     * @param  string $hash Transaction hash (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetTransactionResponse
     */
    public function getTransaction($hash)
    {
        list($response) = $this->getTransactionWithHttpInfo($hash);
        return $response;
    }

    /**
     * Operation getTransactionWithHttpInfo
     *
     * Get transaction
     *
     * @param  string $hash Transaction hash (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionWithHttpInfo($hash)
    {
        $returnType = '\Semux\Client\Model\GetTransactionResponse';
        $request = $this->getTransactionRequest($hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionAsync
     *
     * Get transaction
     *
     * @param  string $hash Transaction hash (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionAsync($hash)
    {
        return $this->getTransactionAsyncWithHttpInfo($hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionAsyncWithHttpInfo
     *
     * Get transaction
     *
     * @param  string $hash Transaction hash (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionAsyncWithHttpInfo($hash)
    {
        $returnType = '\Semux\Client\Model\GetTransactionResponse';
        $request = $this->getTransactionRequest($hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransaction'
     *
     * @param  string $hash Transaction hash (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionRequest($hash)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling getTransaction'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{64}$/", $hash)) {
            throw new \InvalidArgumentException("invalid value for \"hash\" when calling SemuxApi.getTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]{64}$/.");
        }


        $resourcePath = '/transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($hash !== null) {
            $queryParams['hash'] = ObjectSerializer::toQueryValue($hash);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionLimits
     *
     * Get transaction limits
     *
     * @param  string $type Type of transaction (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetTransactionLimitsResponse
     */
    public function getTransactionLimits($type)
    {
        list($response) = $this->getTransactionLimitsWithHttpInfo($type);
        return $response;
    }

    /**
     * Operation getTransactionLimitsWithHttpInfo
     *
     * Get transaction limits
     *
     * @param  string $type Type of transaction (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetTransactionLimitsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionLimitsWithHttpInfo($type)
    {
        $returnType = '\Semux\Client\Model\GetTransactionLimitsResponse';
        $request = $this->getTransactionLimitsRequest($type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetTransactionLimitsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionLimitsAsync
     *
     * Get transaction limits
     *
     * @param  string $type Type of transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionLimitsAsync($type)
    {
        return $this->getTransactionLimitsAsyncWithHttpInfo($type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionLimitsAsyncWithHttpInfo
     *
     * Get transaction limits
     *
     * @param  string $type Type of transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionLimitsAsyncWithHttpInfo($type)
    {
        $returnType = '\Semux\Client\Model\GetTransactionLimitsResponse';
        $request = $this->getTransactionLimitsRequest($type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionLimits'
     *
     * @param  string $type Type of transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionLimitsRequest($type)
    {
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getTransactionLimits'
            );
        }

        $resourcePath = '/transaction-limits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getValidators
     *
     * Get validators
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetValidatorsResponse
     */
    public function getValidators()
    {
        list($response) = $this->getValidatorsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getValidatorsWithHttpInfo
     *
     * Get validators
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetValidatorsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getValidatorsWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetValidatorsResponse';
        $request = $this->getValidatorsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetValidatorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getValidatorsAsync
     *
     * Get validators
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getValidatorsAsync()
    {
        return $this->getValidatorsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getValidatorsAsyncWithHttpInfo
     *
     * Get validators
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getValidatorsAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\GetValidatorsResponse';
        $request = $this->getValidatorsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getValidators'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getValidatorsRequest()
    {

        $resourcePath = '/validators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVote
     *
     * Get vote
     *
     * @param  string $delegate Delegate address (required)
     * @param  string $voter Voter address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetVoteResponse
     */
    public function getVote($delegate, $voter)
    {
        list($response) = $this->getVoteWithHttpInfo($delegate, $voter);
        return $response;
    }

    /**
     * Operation getVoteWithHttpInfo
     *
     * Get vote
     *
     * @param  string $delegate Delegate address (required)
     * @param  string $voter Voter address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetVoteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVoteWithHttpInfo($delegate, $voter)
    {
        $returnType = '\Semux\Client\Model\GetVoteResponse';
        $request = $this->getVoteRequest($delegate, $voter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetVoteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVoteAsync
     *
     * Get vote
     *
     * @param  string $delegate Delegate address (required)
     * @param  string $voter Voter address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVoteAsync($delegate, $voter)
    {
        return $this->getVoteAsyncWithHttpInfo($delegate, $voter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVoteAsyncWithHttpInfo
     *
     * Get vote
     *
     * @param  string $delegate Delegate address (required)
     * @param  string $voter Voter address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVoteAsyncWithHttpInfo($delegate, $voter)
    {
        $returnType = '\Semux\Client\Model\GetVoteResponse';
        $request = $this->getVoteRequest($delegate, $voter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVote'
     *
     * @param  string $delegate Delegate address (required)
     * @param  string $voter Voter address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVoteRequest($delegate, $voter)
    {
        // verify the required parameter 'delegate' is set
        if ($delegate === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delegate when calling getVote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $delegate)) {
            throw new \InvalidArgumentException("invalid value for \"delegate\" when calling SemuxApi.getVote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'voter' is set
        if ($voter === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $voter when calling getVote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $voter)) {
            throw new \InvalidArgumentException("invalid value for \"voter\" when calling SemuxApi.getVote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/vote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delegate !== null) {
            $queryParams['delegate'] = ObjectSerializer::toQueryValue($delegate);
        }
        // query params
        if ($voter !== null) {
            $queryParams['voter'] = ObjectSerializer::toQueryValue($voter);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVotes
     *
     * Get a delegate's votes
     *
     * @param  string $delegate Delegate address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\GetVotesResponse
     */
    public function getVotes($delegate)
    {
        list($response) = $this->getVotesWithHttpInfo($delegate);
        return $response;
    }

    /**
     * Operation getVotesWithHttpInfo
     *
     * Get a delegate's votes
     *
     * @param  string $delegate Delegate address (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\GetVotesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVotesWithHttpInfo($delegate)
    {
        $returnType = '\Semux\Client\Model\GetVotesResponse';
        $request = $this->getVotesRequest($delegate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\GetVotesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVotesAsync
     *
     * Get a delegate's votes
     *
     * @param  string $delegate Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVotesAsync($delegate)
    {
        return $this->getVotesAsyncWithHttpInfo($delegate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVotesAsyncWithHttpInfo
     *
     * Get a delegate's votes
     *
     * @param  string $delegate Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVotesAsyncWithHttpInfo($delegate)
    {
        $returnType = '\Semux\Client\Model\GetVotesResponse';
        $request = $this->getVotesRequest($delegate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVotes'
     *
     * @param  string $delegate Delegate address (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVotesRequest($delegate)
    {
        // verify the required parameter 'delegate' is set
        if ($delegate === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delegate when calling getVotes'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $delegate)) {
            throw new \InvalidArgumentException("invalid value for \"delegate\" when calling SemuxApi.getVotes, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/votes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delegate !== null) {
            $queryParams['delegate'] = ObjectSerializer::toQueryValue($delegate);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAccounts
     *
     * List accounts
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\ListAccountsResponse
     */
    public function listAccounts()
    {
        list($response) = $this->listAccountsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listAccountsWithHttpInfo
     *
     * List accounts
     *
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\ListAccountsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAccountsWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\ListAccountsResponse';
        $request = $this->listAccountsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\ListAccountsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAccountsAsync
     *
     * List accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountsAsync()
    {
        return $this->listAccountsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAccountsAsyncWithHttpInfo
     *
     * List accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountsAsyncWithHttpInfo()
    {
        $returnType = '\Semux\Client\Model\ListAccountsResponse';
        $request = $this->listAccountsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAccounts'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAccountsRequest()
    {

        $resourcePath = '/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerDelegate
     *
     * Register delegate
     *
     * @param  string $from Registering address (required)
     * @param  string $data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DoTransactionResponse
     */
    public function registerDelegate($from, $data, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        list($response) = $this->registerDelegateWithHttpInfo($from, $data, $fee, $nonce, $validateNonce);
        return $response;
    }

    /**
     * Operation registerDelegateWithHttpInfo
     *
     * Register delegate
     *
     * @param  string $from Registering address (required)
     * @param  string $data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DoTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function registerDelegateWithHttpInfo($from, $data, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->registerDelegateRequest($from, $data, $fee, $nonce, $validateNonce);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DoTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation registerDelegateAsync
     *
     * Register delegate
     *
     * @param  string $from Registering address (required)
     * @param  string $data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerDelegateAsync($from, $data, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        return $this->registerDelegateAsyncWithHttpInfo($from, $data, $fee, $nonce, $validateNonce)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation registerDelegateAsyncWithHttpInfo
     *
     * Register delegate
     *
     * @param  string $from Registering address (required)
     * @param  string $data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerDelegateAsyncWithHttpInfo($from, $data, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->registerDelegateRequest($from, $data, $fee, $nonce, $validateNonce);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'registerDelegate'
     *
     * @param  string $from Registering address (required)
     * @param  string $data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function registerDelegateRequest($from, $data, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling registerDelegate'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.registerDelegate, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling registerDelegate'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]+$/", $data)) {
            throw new \InvalidArgumentException("invalid value for \"data\" when calling SemuxApi.registerDelegate, must conform to the pattern /^(0x)?[0-9a-fA-F]+$/.");
        }

        if ($fee !== null && !preg_match("/^\\d+$/", $fee)) {
            throw new \InvalidArgumentException("invalid value for \"fee\" when calling SemuxApi.registerDelegate, must conform to the pattern /^\\d+$/.");
        }

        if ($nonce !== null && !preg_match("/^\\d+$/", $nonce)) {
            throw new \InvalidArgumentException("invalid value for \"nonce\" when calling SemuxApi.registerDelegate, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/transaction/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($data !== null) {
            $queryParams['data'] = ObjectSerializer::toQueryValue($data);
        }
        // query params
        if ($fee !== null) {
            $queryParams['fee'] = ObjectSerializer::toQueryValue($fee);
        }
        // query params
        if ($nonce !== null) {
            $queryParams['nonce'] = ObjectSerializer::toQueryValue($nonce);
        }
        // query params
        if ($validateNonce !== null) {
            $queryParams['validateNonce'] = ObjectSerializer::toQueryValue($validateNonce);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signMessage
     *
     * Sign a message
     *
     * @param  string $address Signing address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $message Message to sign in UTF-8 string (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\SignMessageResponse
     */
    public function signMessage($address, $message)
    {
        list($response) = $this->signMessageWithHttpInfo($address, $message);
        return $response;
    }

    /**
     * Operation signMessageWithHttpInfo
     *
     * Sign a message
     *
     * @param  string $address Signing address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $message Message to sign in UTF-8 string (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\SignMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signMessageWithHttpInfo($address, $message)
    {
        $returnType = '\Semux\Client\Model\SignMessageResponse';
        $request = $this->signMessageRequest($address, $message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\SignMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signMessageAsync
     *
     * Sign a message
     *
     * @param  string $address Signing address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $message Message to sign in UTF-8 string (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMessageAsync($address, $message)
    {
        return $this->signMessageAsyncWithHttpInfo($address, $message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signMessageAsyncWithHttpInfo
     *
     * Sign a message
     *
     * @param  string $address Signing address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $message Message to sign in UTF-8 string (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signMessageAsyncWithHttpInfo($address, $message)
    {
        $returnType = '\Semux\Client\Model\SignMessageResponse';
        $request = $this->signMessageRequest($address, $message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signMessage'
     *
     * @param  string $address Signing address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $message Message to sign in UTF-8 string (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signMessageRequest($address, $message)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling signMessage'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.signMessage, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'message' is set
        if ($message === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling signMessage'
            );
        }

        $resourcePath = '/sign-message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signRawTransaction
     *
     * Sign an unsigned raw transaction
     *
     * @param  string $raw Unsigned raw transaction encoded in hexadecimal string. (required)
     * @param  string $address Signer&#39;s address. This address must exist in the wallet. (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\SignRawTransactionResponse
     */
    public function signRawTransaction($raw, $address)
    {
        list($response) = $this->signRawTransactionWithHttpInfo($raw, $address);
        return $response;
    }

    /**
     * Operation signRawTransactionWithHttpInfo
     *
     * Sign an unsigned raw transaction
     *
     * @param  string $raw Unsigned raw transaction encoded in hexadecimal string. (required)
     * @param  string $address Signer&#39;s address. This address must exist in the wallet. (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\SignRawTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function signRawTransactionWithHttpInfo($raw, $address)
    {
        $returnType = '\Semux\Client\Model\SignRawTransactionResponse';
        $request = $this->signRawTransactionRequest($raw, $address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\SignRawTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation signRawTransactionAsync
     *
     * Sign an unsigned raw transaction
     *
     * @param  string $raw Unsigned raw transaction encoded in hexadecimal string. (required)
     * @param  string $address Signer&#39;s address. This address must exist in the wallet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signRawTransactionAsync($raw, $address)
    {
        return $this->signRawTransactionAsyncWithHttpInfo($raw, $address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signRawTransactionAsyncWithHttpInfo
     *
     * Sign an unsigned raw transaction
     *
     * @param  string $raw Unsigned raw transaction encoded in hexadecimal string. (required)
     * @param  string $address Signer&#39;s address. This address must exist in the wallet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signRawTransactionAsyncWithHttpInfo($raw, $address)
    {
        $returnType = '\Semux\Client\Model\SignRawTransactionResponse';
        $request = $this->signRawTransactionRequest($raw, $address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signRawTransaction'
     *
     * @param  string $raw Unsigned raw transaction encoded in hexadecimal string. (required)
     * @param  string $address Signer&#39;s address. This address must exist in the wallet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signRawTransactionRequest($raw, $address)
    {
        // verify the required parameter 'raw' is set
        if ($raw === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $raw when calling signRawTransaction'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]+$/", $raw)) {
            throw new \InvalidArgumentException("invalid value for \"raw\" when calling SemuxApi.signRawTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]+$/.");
        }

        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling signRawTransaction'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.signRawTransaction, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }


        $resourcePath = '/sign-raw-transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($raw !== null) {
            $queryParams['raw'] = ObjectSerializer::toQueryValue($raw);
        }
        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transfer
     *
     * Transfer coins
     *
     * @param  string $from Sender&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Recipient&#39;s address (required)
     * @param  string $value Amount of SEM to transfer in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     * @param  string $data Transaction data encoded in hexadecimal string (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DoTransactionResponse
     */
    public function transfer($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false', $data = null)
    {
        list($response) = $this->transferWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce, $data);
        return $response;
    }

    /**
     * Operation transferWithHttpInfo
     *
     * Transfer coins
     *
     * @param  string $from Sender&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Recipient&#39;s address (required)
     * @param  string $value Amount of SEM to transfer in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     * @param  string $data Transaction data encoded in hexadecimal string (optional)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DoTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false', $data = null)
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->transferRequest($from, $to, $value, $fee, $nonce, $validateNonce, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DoTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferAsync
     *
     * Transfer coins
     *
     * @param  string $from Sender&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Recipient&#39;s address (required)
     * @param  string $value Amount of SEM to transfer in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     * @param  string $data Transaction data encoded in hexadecimal string (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferAsync($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false', $data = null)
    {
        return $this->transferAsyncWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferAsyncWithHttpInfo
     *
     * Transfer coins
     *
     * @param  string $from Sender&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Recipient&#39;s address (required)
     * @param  string $value Amount of SEM to transfer in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     * @param  string $data Transaction data encoded in hexadecimal string (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferAsyncWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false', $data = null)
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->transferRequest($from, $to, $value, $fee, $nonce, $validateNonce, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfer'
     *
     * @param  string $from Sender&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Recipient&#39;s address (required)
     * @param  string $value Amount of SEM to transfer in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     * @param  string $data Transaction data encoded in hexadecimal string (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function transferRequest($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false', $data = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling transfer'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.transfer, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling transfer'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.transfer, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling transfer'
            );
        }
        if (!preg_match("/^\\d+$/", $value)) {
            throw new \InvalidArgumentException("invalid value for \"value\" when calling SemuxApi.transfer, must conform to the pattern /^\\d+$/.");
        }

        if ($fee !== null && !preg_match("/^\\d+$/", $fee)) {
            throw new \InvalidArgumentException("invalid value for \"fee\" when calling SemuxApi.transfer, must conform to the pattern /^\\d+$/.");
        }

        if ($nonce !== null && !preg_match("/^\\d+$/", $nonce)) {
            throw new \InvalidArgumentException("invalid value for \"nonce\" when calling SemuxApi.transfer, must conform to the pattern /^\\d+$/.");
        }

        if ($data !== null && !preg_match("/^(0x)?[0-9a-fA-F]+$/", $data)) {
            throw new \InvalidArgumentException("invalid value for \"data\" when calling SemuxApi.transfer, must conform to the pattern /^(0x)?[0-9a-fA-F]+$/.");
        }


        $resourcePath = '/transaction/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($fee !== null) {
            $queryParams['fee'] = ObjectSerializer::toQueryValue($fee);
        }
        // query params
        if ($nonce !== null) {
            $queryParams['nonce'] = ObjectSerializer::toQueryValue($nonce);
        }
        // query params
        if ($validateNonce !== null) {
            $queryParams['validateNonce'] = ObjectSerializer::toQueryValue($validateNonce);
        }
        // query params
        if ($data !== null) {
            $queryParams['data'] = ObjectSerializer::toQueryValue($data);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unvote
     *
     * Unvote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DoTransactionResponse
     */
    public function unvote($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        list($response) = $this->unvoteWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce);
        return $response;
    }

    /**
     * Operation unvoteWithHttpInfo
     *
     * Unvote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DoTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function unvoteWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->unvoteRequest($from, $to, $value, $fee, $nonce, $validateNonce);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DoTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unvoteAsync
     *
     * Unvote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unvoteAsync($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        return $this->unvoteAsyncWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unvoteAsyncWithHttpInfo
     *
     * Unvote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unvoteAsyncWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->unvoteRequest($from, $to, $value, $fee, $nonce, $validateNonce);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unvote'
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unvoteRequest($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling unvote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.unvote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling unvote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.unvote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling unvote'
            );
        }
        if (!preg_match("/^\\d+$/", $value)) {
            throw new \InvalidArgumentException("invalid value for \"value\" when calling SemuxApi.unvote, must conform to the pattern /^\\d+$/.");
        }

        if ($fee !== null && !preg_match("/^\\d+$/", $fee)) {
            throw new \InvalidArgumentException("invalid value for \"fee\" when calling SemuxApi.unvote, must conform to the pattern /^\\d+$/.");
        }

        if ($nonce !== null && !preg_match("/^\\d+$/", $nonce)) {
            throw new \InvalidArgumentException("invalid value for \"nonce\" when calling SemuxApi.unvote, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/transaction/unvote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($fee !== null) {
            $queryParams['fee'] = ObjectSerializer::toQueryValue($fee);
        }
        // query params
        if ($nonce !== null) {
            $queryParams['nonce'] = ObjectSerializer::toQueryValue($nonce);
        }
        // query params
        if ($validateNonce !== null) {
            $queryParams['validateNonce'] = ObjectSerializer::toQueryValue($validateNonce);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyMessage
     *
     * Verify a message
     *
     * @param  string $address Address of the message signer (required)
     * @param  string $message Message in UTF-8 string (required)
     * @param  string $signature Signature to verify (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\VerifyMessageResponse
     */
    public function verifyMessage($address, $message, $signature)
    {
        list($response) = $this->verifyMessageWithHttpInfo($address, $message, $signature);
        return $response;
    }

    /**
     * Operation verifyMessageWithHttpInfo
     *
     * Verify a message
     *
     * @param  string $address Address of the message signer (required)
     * @param  string $message Message in UTF-8 string (required)
     * @param  string $signature Signature to verify (required)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\VerifyMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyMessageWithHttpInfo($address, $message, $signature)
    {
        $returnType = '\Semux\Client\Model\VerifyMessageResponse';
        $request = $this->verifyMessageRequest($address, $message, $signature);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\VerifyMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyMessageAsync
     *
     * Verify a message
     *
     * @param  string $address Address of the message signer (required)
     * @param  string $message Message in UTF-8 string (required)
     * @param  string $signature Signature to verify (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMessageAsync($address, $message, $signature)
    {
        return $this->verifyMessageAsyncWithHttpInfo($address, $message, $signature)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyMessageAsyncWithHttpInfo
     *
     * Verify a message
     *
     * @param  string $address Address of the message signer (required)
     * @param  string $message Message in UTF-8 string (required)
     * @param  string $signature Signature to verify (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMessageAsyncWithHttpInfo($address, $message, $signature)
    {
        $returnType = '\Semux\Client\Model\VerifyMessageResponse';
        $request = $this->verifyMessageRequest($address, $message, $signature);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyMessage'
     *
     * @param  string $address Address of the message signer (required)
     * @param  string $message Message in UTF-8 string (required)
     * @param  string $signature Signature to verify (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyMessageRequest($address, $message, $signature)
    {
        // verify the required parameter 'address' is set
        if ($address === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling verifyMessage'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $address)) {
            throw new \InvalidArgumentException("invalid value for \"address\" when calling SemuxApi.verifyMessage, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'message' is set
        if ($message === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling verifyMessage'
            );
        }
        // verify the required parameter 'signature' is set
        if ($signature === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signature when calling verifyMessage'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{192}$/", $signature)) {
            throw new \InvalidArgumentException("invalid value for \"signature\" when calling SemuxApi.verifyMessage, must conform to the pattern /^(0x)?[0-9a-fA-F]{192}$/.");
        }


        $resourcePath = '/verify-message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }
        // query params
        if ($signature !== null) {
            $queryParams['signature'] = ObjectSerializer::toQueryValue($signature);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vote
     *
     * Vote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Semux\Client\Model\DoTransactionResponse
     */
    public function vote($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        list($response) = $this->voteWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce);
        return $response;
    }

    /**
     * Operation voteWithHttpInfo
     *
     * Vote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \Semux\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Semux\Client\Model\DoTransactionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function voteWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->voteRequest($from, $to, $value, $fee, $nonce, $validateNonce);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Semux\Client\Model\DoTransactionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voteAsync
     *
     * Vote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voteAsync($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        return $this->voteAsyncWithHttpInfo($from, $to, $value, $fee, $nonce, $validateNonce)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voteAsyncWithHttpInfo
     *
     * Vote
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voteAsyncWithHttpInfo($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        $returnType = '\Semux\Client\Model\DoTransactionResponse';
        $request = $this->voteRequest($from, $to, $value, $fee, $nonce, $validateNonce);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vote'
     *
     * @param  string $from Voter&#39;s address. The address must exist in the wallet.data of this Semux node. (required)
     * @param  string $to Delegate address (required)
     * @param  string $value Number of votes in nano SEM (required)
     * @param  string $fee Transaction fee in nano SEM, default to minimum fee if omitted (optional)
     * @param  string $nonce Transaction nonce, default to sender&#39;s nonce if omitted (optional)
     * @param  bool $validateNonce Whether validate tx nonce against the current account state, default to false if omitted (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voteRequest($from, $to, $value, $fee = null, $nonce = null, $validateNonce = 'false')
    {
        // verify the required parameter 'from' is set
        if ($from === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling vote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $from)) {
            throw new \InvalidArgumentException("invalid value for \"from\" when calling SemuxApi.vote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'to' is set
        if ($to === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling vote'
            );
        }
        if (!preg_match("/^(0x)?[0-9a-fA-F]{40}$/", $to)) {
            throw new \InvalidArgumentException("invalid value for \"to\" when calling SemuxApi.vote, must conform to the pattern /^(0x)?[0-9a-fA-F]{40}$/.");
        }

        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling vote'
            );
        }
        if (!preg_match("/^\\d+$/", $value)) {
            throw new \InvalidArgumentException("invalid value for \"value\" when calling SemuxApi.vote, must conform to the pattern /^\\d+$/.");
        }

        if ($fee !== null && !preg_match("/^\\d+$/", $fee)) {
            throw new \InvalidArgumentException("invalid value for \"fee\" when calling SemuxApi.vote, must conform to the pattern /^\\d+$/.");
        }

        if ($nonce !== null && !preg_match("/^\\d+$/", $nonce)) {
            throw new \InvalidArgumentException("invalid value for \"nonce\" when calling SemuxApi.vote, must conform to the pattern /^\\d+$/.");
        }


        $resourcePath = '/transaction/vote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($fee !== null) {
            $queryParams['fee'] = ObjectSerializer::toQueryValue($fee);
        }
        // query params
        if ($nonce !== null) {
            $queryParams['nonce'] = ObjectSerializer::toQueryValue($nonce);
        }
        // query params
        if ($validateNonce !== null) {
            $queryParams['validateNonce'] = ObjectSerializer::toQueryValue($validateNonce);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
